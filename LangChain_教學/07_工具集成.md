# 第七章：工具集成

本章將介紹如何在 LangChain 2.0 中將外部工具與語言模型集成，大大擴展 AI 應用的功能範圍。

## 7.1 工具的概念

工具（Tools）允許語言模型執行諸如搜索網絡、執行計算、訪問數據庫等實際操作。LangChain 2.0 提供了標準化的方式來定義和使用工具：

- 工具是帶有輸入/輸出的函數
- 語言模型可以基於用戶需求選擇適當的工具
- 工具執行結果可以回饋給模型產生更精確的回應

## 7.2 創建基本工具

在 LangChain 中，工具是由函數和元數據組成的：

```python
from langchain.tools import tool

@tool
def search(query: str) -> str:
    """搜索網絡以獲取有關特定主題的信息。"""
    # 這裡是一個模擬的搜索功能
    return f"這是關於'{query}'的搜索結果..."

@tool
def calculator(expression: str) -> str:
    """計算數學表達式的結果。"""
    try:
        return str(eval(expression))
    except Exception as e:
        return f"計算錯誤: {str(e)}"
```

## 7.3 內置工具

LangChain 提供了許多內置工具：

```python
from langchain.agents.tools import Tool
from langchain_community.tools import WikipediaQueryRun
from langchain_community.utilities import WikipediaAPIWrapper

# 維基百科查詢工具
wikipedia_tool = WikipediaQueryRun(api_wrapper=WikipediaAPIWrapper())

# 包裝成標準工具
wikipedia = Tool(
    name="Wikipedia",
    description="搜索維基百科獲取信息",
    func=wikipedia_tool.run
)
```

## 7.4 工具與代理結合

工具是強大的，但真正的力量來自於將工具與語言模型結合，創建能夠決定何時使用工具的代理：

```python
from langchain.agents import AgentExecutor, create_react_agent
from langchain_community.llms import Ollama
from langchain_core.prompts import PromptTemplate

# 初始化 LLM
llm = Ollama(model="llama2")

# 定義工具列表
tools = [search, calculator]

# 創建提示模板
prompt = PromptTemplate.from_template("""
你是一個能夠使用工具解決問題的助手。
可用工具:
{tools}

使用以下格式:
問題: 用戶的問題
思考: 你對如何解決問題的思考
行動: 工具名稱 (工具參數)
觀察: 工具返回的結果
思考: 你對結果的思考
行動: 工具名稱 (工具參數)
觀察: 工具返回的結果
...
回答: 最終回答

問題: {input}
""")

# 創建代理
agent = create_react_agent(llm, tools, prompt)

# 創建代理執行器
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

# 運行代理
result = agent_executor.invoke({"input": "計算 (53 * 19) 並告訴我這個數字的平方根是多少"})
print(result["output"])
```

## 7.5 Ollama 與工具集成

由於 Ollama 提供的模型可能不像一些商業模型那樣完全支持代理功能，我們可以使用以下策略：

### 7.5.1 結構化輸出解析

定義工具選擇的格式，並使用輸出解析器解析模型回應：

```python
from langchain_core.pydantic_v1 import BaseModel, Field
from langchain_core.output_parsers import PydanticOutputParser

# 定義工具選擇架構
class ToolSelection(BaseModel):
    tool_name: str = Field(description="要使用的工具名稱")
    tool_input: str = Field(description="傳入工具的參數")

# 創建解析器
parser = PydanticOutputParser(pydantic_object=ToolSelection)

# 創建工具選擇提示
tool_prompt = PromptTemplate.from_template("""
你需要選擇最合適的工具來回答用戶的問題。

可用工具:
- search: 搜索網絡以獲取有關特定主題的信息
- calculator: 計算數學表達式的結果

用戶問題: {question}

{format_instructions}
""")

# 工具選擇鏈
tool_selection_chain = (
    tool_prompt.format(
        question="{question}",
        format_instructions=parser.get_format_instructions()
    )
    | llm
    | parser
)

# 使用工具選擇
def use_tools(question):
    try:
        # 選擇工具
        selection = tool_selection_chain.invoke({"question": question})
        tool_name = selection.tool_name
        tool_input = selection.tool_input
        
        # 執行工具
        if tool_name == "search":
            tool_result = search(tool_input)
        elif tool_name == "calculator":
            tool_result = calculator(tool_input)
        else:
            tool_result = "未知工具"
            
        # 生成最終回應
        final_prompt = f"""
        用戶問題: {question}
        
        工具結果: {tool_result}
        
        請基於工具結果提供完整回答。
        """
        
        return llm.invoke(final_prompt)
    
    except Exception as e:
        # 如果解析失敗，直接使用 LLM 回答
        return llm.invoke(f"請回答以下問題: {question}")
```

### 7.5.2 自定義工具執行流程

對於更複雜的場景，可以手動實現工具選擇和執行的流程：

```python
def execute_tools_workflow(question):
    # 第一步：分析問題以確定是否需要工具
    analysis_prompt = f"分析以下問題是否需要使用特殊工具來回答: '{question}'. 只回答'需要'或'不需要'。"
    needs_tool = "需要" in llm.invoke(analysis_prompt)
    
    if not needs_tool:
        # 直接回答
        return llm.invoke(f"請回答: {question}")
    
    # 第二步：決定使用哪個工具
    tool_selection_prompt = f"""
    問題: '{question}'
    從以下工具中選擇最合適的一個來回答問題:
    1. search - 搜索網絡獲取信息
    2. calculator - 執行數學計算
    只回答數字1或2。
    """
    
    tool_choice = llm.invoke(tool_selection_prompt).strip()
    
    # 第三步：獲取工具參數
    param_prompt = f"問題: '{question}'. 請提取出需要傳入工具的具體參數，不要包含其他解釋。"
    tool_param = llm.invoke(param_prompt).strip()
    
    # 第四步：執行工具
    if "1" in tool_choice:
        tool_result = search(tool_param)
    else:
        tool_result = calculator(tool_param)
    
    # 第五步：生成最終回應
    final_prompt = f"""
    用戶問題: {question}
    
    工具結果: {tool_result}
    
    請基於工具結果提供完整回答。
    """
    
    return llm.invoke(final_prompt)
```

## 7.6 複雜工具集成

### 7.6.1 網頁瀏覽工具

```python
from langchain_community.tools import BrowserTool

browser = BrowserTool()

def browse_website(url: str) -> str:
    """訪問網頁並提取主要內容。"""
    return browser.run(url)
```

### 7.6.2 文檔查詢工具

```python
from langchain.text_splitter import CharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_community.embeddings import OllamaEmbeddings
from langchain.chains import RetrievalQA

def create_document_tool(file_path):
    # 加載文檔
    with open(file_path, 'r') as file:
        text = file.read()
    
    # 切分文檔
    text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)
    chunks = text_splitter.split_text(text)
    
    # 創建向量存儲
    embeddings = OllamaEmbeddings(model="llama2")
    vectorstore = FAISS.from_texts(chunks, embeddings)
    
    # 創建 QA 鏈
    qa_chain = RetrievalQA.from_chain_type(
        llm=Ollama(model="llama2"),
        chain_type="stuff",
        retriever=vectorstore.as_retriever()
    )
    
    @tool
    def document_qa(query: str) -> str:
        """從文檔中查詢信息。"""
        return qa_chain.run(query)
    
    return document_qa
```

## 7.7 使用示例代碼

本章的工具集成示例可以在 `examples/tools_example.py` 中找到：

```bash
python examples/tools_example.py
```

## 下一步

學習了如何集成工具後，讓我們在下一章節中探索實際應用案例，將之前學到的所有技術結合起來構建完整的應用。
